<?php

/**
 * @file
 * Generates and displays API documentation pages.
 *
 * This is an implementation of a subset of the Doxygen documentation generator
 * specification, tuned to produce output that best benefits the Drupal Codex
 * base. It is designed to assume the code it documents follows Drupal coding
 * conventions, and supports documentation blocks in formats described on
 * http://drupal.org/node/1354
 */

/**
 * Regular expression for matching file names.
 */
define('API_RE_FILENAME', '([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+)');

/**
 * Regular expression for matching PHP functions and methods in text.
 *
 * These are patterns like ClassName::methodName(), or just function_name().
 * Possibly with namespaces.
 */
define('API_RE_FUNCTION_IN_TEXT', '\\\\*[a-zA-Z_\x7f-\xff][\\\\a-zA-Z0-9_\x7f-\xff:]*');

/**
 * Regular expression for matching group/topic names.
 */
define('API_RE_GROUP_NAME', '[a-zA-Z_0-9\.\-]+');

/**
 * Regular expression for matching hook names.
 *
 * Since the actual PHP function name already has a prefix, these can
 * technically start with a number, although it's unlikely.
 */
define('API_RE_HOOK_NAME', '[a-zA-Z0-9_\x7f-\xff]+');

/**
 * Regular expression for aggressively matching class names in text.
 *
 * Although class names can technically be just like function names, we
 * only want to match class names if they include a capital letter, so as
 * not to be too overly aggressive. Possibly can include namespaces.
 */
define('API_RE_CLASS_NAME_TEXT', '\\\\*[\\\\a-zA-Z0-9_\x7f-\xff]*[A-Z][\\\\a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for less-aggressively matching class names in text.
 *
 * Matches class names that are namespaced, because we know these are not just
 * plain text words.
 */
define('API_RE_DEFINITE_CLASS_NAME_TEXT', '[\\\\a-zA-Z0-9_\x7f-\xff]*[\\\\][\\\\a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for starting inline \@tags.
 */
define('API_RE_TAG_START', '(?<!\\\)@');

/**
 * Regular expression for word boundary start for API linking.
 */
define('API_RE_WORD_BOUNDARY_START', '(?<=\s|^|\()');

/**
 * Regular expression for word boundary end for API linking.
 */
define('API_RE_WORD_BOUNDARY_END', '(?=$|[\s.,:;?!)])');

/**
 * File path separator.
 */
define('API_FILEPATH_SEPARATOR', '/');

/**
 * Namespace separator.
 */
define('API_NAMESPACE_SEPARATOR', '\\');

/**
 * File path separator replacement.
 */
define('API_FILEPATH_SEPARATOR_REPLACEMENT', '!');

/**
 * File path separator replacement for API v 1.3.
 */
define('API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT', '--');

/**
 * Implements hook_help().
 */
function api_help($path, $arg) {
  switch ($path) {
    case 'admin/help#api':
      return t('
<p>This is an implementation of a subset of the Doxygen documentation generator specification, tuned to produce output that best benefits the Drupal code base. It is designed to assume the code it documents follows Drupal coding conventions, and supports documentation blocks in formats described on !doxygen_link.</p>

<h3>Set up</h3>

<p>Visit the !api_settings_page to configure the module. You must have the relevant Drupal code base on the same machine as the site hosting the API module. Set up Projects and Branches to index your Drupal code base.</p>

<p>Indexing of PHP functions is also supported, by setting up a PHP Reference Branch. If the site has internet access, then the default settings should work fine. For local development environments that have a PHP manual installed, you can edit the link path to point to the appropriate location.</p>

<p>The module indexes code branches during cron runs, so make sure the site has cron functionality set up properly.</p>
', array('!api_settings_page' => l(t('API settings page'), 'admin/config/development/api'), '!doxygen_link' => l('http://drupal.org/node/1354', 'http://drupal.org/node/1354')));

    case 'admin/config/development/api':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('File parse queue: parses PHP and other files for display.') . '</li>' .
        '<li>' . t('Branch update queue: scans branches for files that have been updated or removed, and adds jobs to the file parse and node cleanup queues.') . '</li>' .
        '<li>' . t('Node cleanup queue: deletes nodes for removed files.') . '</li>' .
        '<li>' . t('Reset the file parse queue: remove existing jobs and mark files as not queued for parsing. Next time each branch is scanned, files will be re-added to the queue as needed.') . '</li>' .
        '</ul>';

    case 'admin/config/development/api/projects':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('Project: A module, theme, Drupal Core, or other group of files that the API module is parsing.') . '</li>' .
        '<li>' . t('Project type: Normally "core", "module", "theme", or "library". The type "core" is special: core project functions are given priority when turning function, class, and other names into links in code listings.') . '</li>' .
        '</ul>';

    case 'admin/config/development/api/branches':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('Project: A module, theme, Drupal Core, or other group of files that the API module is parsing. Set up on the Projects tab.') . '</li>' .
        '<li>' . t('Branch: Within a Project, a particular version of the files (6.x-1.x, 7.x, 7.x-1.3, etc.).') . '</li>' .
        '<li>' . t('Core compatibility: usually 7.x, 6.x, etc. Branches with matching core compatibility are used to make cross-project links, and the default project and core compatibility (set on the Overview tab) determines the default branch.') . '</li>' .
        '<li>' . t('Reparse: Force a parse of every file in the branch, starting next time the branch is updated.') . '</li>' .
        '<li>' . t('Update: Force a scan of the file directories in the branch for updated and removed files. This normally happens during cron runs after a minimum time (set on branch edit page) has passed.') . '</li>' .
        '</ul>';

    case 'admin/config/development/api/php_branches':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('PHP reference branch: an external web site that is used to make links to externally-defined functions (such as making links to php.net for the built-in PHP functions).') . '</li>' .
        '<li>' . t('Update: Force a scan of the download of function information. This normally happens during cron runs after a minimum time (set on branch edit page) has passed.') . '</li>' .
        '</ul>';
  }
}

/**
 * Returns a list of all defined branches.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch objects, in order by branch weight.
 */
function api_get_branches($_reset = FALSE) {
  static $branches;

  if (!isset($branches) || $_reset) {
    $query = db_select('api_branch', 'b')
      ->fields('b');
    $query->leftJoin('api_project', 'p', 'b.project = p.project_name');
    $result = $query
      ->fields('p', array('project_title', 'project_type'))
      ->orderBy('weight', 'ASC')
      ->execute();
    $branches = array();
    foreach ($result as $branch) {
      api_unpack_branch_data($branch);
      $branches[$branch->branch_id] = $branch;
    }
  }

  return $branches;
}

/**
 * Returns a branch, given a branch ID number.
 *
 * @param $id
 *   Branch ID number.
 *
 * @return
 *   Branch object for the given branch ID. If $id is not set, the default
 *   branch is returned. If the requested branch does not exist, NULL.
 */
function api_get_branch_by_id($id = NULL) {
  $branches = api_get_branches();
  if (!isset($id)) {
    $id = variable_get('api_default_branch', NULL);
  }
  if (isset($id) && isset($branches[$id])) {
    return $branches[$id];
  }

  return NULL;
}

/**
 * Returns the list of currently-used branch names across all projects.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch names in use.
 */
function api_get_branch_names($_reset = FALSE) {
  static $branch_names;

  if (!isset($branch_names) || $_reset) {
    $result = db_select('api_branch', 'b')
      ->fields('b', array('branch_name'))
      ->execute()
      ->fetchCol();
    $branch_names = drupal_map_assoc($result);
  }

  return $branch_names;
}

/**
 * Returns a list of all defined branches.
 *
 * @param $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return
 *   Array of branch objects, in order by branch weight.
 */
function api_get_php_branches($_reset = FALSE) {
  static $branches;

  if (!isset($branches) || $_reset) {
    $result = db_select('api_php_branch', 'b')
      ->fields('b')
      ->orderBy('title')
      ->execute();
    $branches = array();
    foreach ($result as $branch) {
      api_unpack_branch_data($branch);
      $branches[$branch->branch_id] = $branch;
    }
  }

  return $branches;
}

/**
 * Implements hook_menu().
 */
function api_menu() {
  $items = array();

  // Admin overview.
  $items['admin/config/development/api'] = array(
    'title' => 'API reference',
    'description' => 'Configure projects and branches for API documentation.',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_page_admin_overview',
    'file' => 'api.admin.inc',
  );

  $items['admin/config/development/api/overview'] = array(
    'title' => 'Overview',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/config/development/api/reset_queue'] = array(
    'title' => 'Reset parse queue',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_reset_queue_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Projects admin.
  $items['admin/config/development/api/projects'] = array(
    'title' => 'Projects',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_project_list',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/config/development/api/projects/list'] = array(
    'title' => 'List',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/development/api/projects/new'] = array(
    'title' => 'New project',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_project_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/development/api/projects/%'] = array(
    'title' => 'Edit project',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_project_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/projects/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_project_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Branches admin.
  $items['admin/config/development/api/branches'] = array(
    'title' => 'Branches',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_branch_list',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  $items['admin/config/development/api/branches/list'] = array(
    'title' => 'List',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/development/api/branches/new'] = array(
    'title' => 'New branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%'] = array(
    'title' => 'Edit branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/reparse'] = array(
    'title' => 'Reparse branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_reparse',
    'page arguments' => array(5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/update'] = array(
    'title' => 'Update branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_update',
    'page arguments' => array('branch', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // PHP reference branches admin.
  $items['admin/config/development/api/php_branches'] = array(
    'title' => 'PHP reference branches',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_php_branch_list',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 15,
  );

  $items['admin/config/development/api/php_branches/new'] = array(
    'title' => 'New PHP reference branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_php_branch_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/%'] = array(
    'title' => 'Edit PHP reference branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_php_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_php_branch_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/%/update'] = array(
    'title' => 'Update branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_update',
    'page arguments' => array('php_branch', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Comment admin.
  if (module_exists('comment')) {
    $items['admin/config/development/api/comments'] = array(
      'title' => 'Comment settings',
      'access arguments' => array('administer API reference'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_comments_settings_form'),
      'file' => 'api.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 20,
    );

    $items['admin/config/development/api/comments/apply'] = array(
      'title' => 'Apply comment settings',
      'access arguments' => array('administer API reference'),
      'page callback' => 'api_apply_comment_settings',
      'file' => 'api.admin.inc',
      'type' => MENU_CALLBACK,
    );
  }

  // The rest of the menu items require there to be at least one branch.
  $branches = api_get_branches();
  if (!count($branches)) {
    return $items;
  }

  $default_branch = api_get_branch_by_id();
  $projects = _api_make_menu_projects();
  if (!count($projects) || !isset($default_branch->project)) {
    return $items;
  }

  // Legacy search URLs.
  $items['api/search'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/' . $default_branch->branch_name . '/search'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  foreach ($branches as $branch) {
    if (!isset($items['api/search/' . $branch->branch_name . '/%'])) {
      $items['api/search/' . $branch->branch_name . '/%'] = array(
        'page callback' => 'api_legacy_search_redirect',
        'page arguments' => array($branch, 3),
        'access arguments' => array('access API reference'),
        'type' => MENU_CALLBACK,
        'file' => 'legacy.inc',
      );
    }
  }

  $items['apis'] = array(
    'title' => 'API search',
    'page callback' => 'api_search_redirect',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // OpenSearch metadata callback.
  $items['api/opensearch/%/%'] = array(
    'page callback' => 'api_opensearch',
    'page arguments' => array(2, 3),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // OpenSearch suggestions callback.
  $items['api/suggest/%/%/%menu_tail'] = array(
    'page callback' => 'api_suggest',
    'page arguments' => array(2, 3, 4),
    'load arguments' => array('%map', '%index'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Autocomplete callbacks.

  // Projects callback.
  $items['api/project/autocomplete'] = array(
    'page callback' => 'api_project_autocomplete',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  // Search callback
  $items['api/search/autocomplete'] = array(
    'page callback' => 'api_search_autocomplete',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  // Function dumps for IDEs and code editors.
  $items['api/function_dump/%'] = array(
    'page callback' => 'api_page_function_dump',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Listings

  // Projects
  $items['api/projects'] = array(
    'title' => 'Projects',
    'page callback' => 'api_page_projects',
    'access arguments' => array('access API reference'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'api.pages.inc',
  );

  // Files
  $items['api/%/%api_filename'] = array(
    'title' => 'File',
    'load arguments' => array(1, 3), // project, branch
    'page callback' => 'api_page_file',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%api_filename/theme_invokes'] = array(
    'title' => 'File',
    'load arguments' => array(1, 4), // project, branch
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(2, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Items
  $items['api/%/%/function/%api_item'] = array(
    'title' => 'Function',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/function/calls/%api_item'] = array(
    'title' => 'Function calls',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'calls'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/implementations/%api_item'] = array(
    'title' => 'Function implementations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'implementations'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/references/%api_item'] = array(
    'title' => 'Function references',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'references'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/invokes/%api_item'] = array(
    'title' => 'Hook invocations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/theme_invokes/%api_item'] = array(
    'title' => 'Theme invokes',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/overrides/%api_item'] = array(
    'title' => 'Function calls',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'overrides'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/constant/%api_item'] = array(
    'title' => 'Constant',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'constant'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/global/%api_item'] = array(
    'title' => 'Global',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'global'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/property/%api_item'] = array(
    'title' => 'Property',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'property'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/%api_item'] = array(
    'title' => 'Class',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/hierarchy/%api_item'] = array(
    'title' => 'Class hierarchy',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class_hierarchy',
    'page arguments' => array(5),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/%api_item'] = array(
    'title' => 'Interface',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/hierarchy/%api_item'] = array(
    'title' => 'Class hierarchy',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class_hierarchy',
    'page arguments' => array(5),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/group/%api_item'] = array(
    'title' => 'Group',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_group',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/namespace/%/%'] = array(
    'title' => 'Namespace',
    'page callback' => 'api_page_namespace',
    'page arguments' => array(1, 4, 3), // project, branch, namespace
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  foreach ($branches as $branch) {
    $is_default = !is_null($default_branch) && ($branch->branch_name === $projects[$branch->project]['use branch']);

    // Main branch page
    if ($is_default) {
      $items['api/' . $branch->project] = array(
        'title' => 'API reference',
        'page callback' => 'api_page_branch',
        'page arguments' => array($branch),
        'access arguments' => array('access API reference'),
        'type' => $branch->branch_id === $default_branch->branch_id ? MENU_NORMAL_ITEM : MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_branch',
      'page arguments' => array($branch),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    $items['api/' . $branch->project . '/' . $branch->branch_name . '/search'] = array(
      'title' => $branch->title,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_search_form', $branch),
      'access arguments' => array('access API reference'),
      'type' => MENU_NORMAL_ITEM,
    );

    $items['api/' . $branch->project . '/' . $branch->branch_name . '/search/%menu_tail'] = array(
      'title' => $branch->title,
      'page callback' => 'api_search_listing',
      'page arguments' => array($branch, 4),
      'load arguments' => array('%map', '%index'),
      'access arguments' => array('access API reference'),
      'type' => MENU_NORMAL_ITEM,
      'file' => 'api.pages.inc',
    );

    // Listings

    if ($is_default) {
      $items['api/' . $branch->project . '/functions'] = array(
        'title' => 'Functions',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'function'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/functions/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'function'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/constants'] = array(
        'title' => 'Constants',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'constant'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/constants/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'constant'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/globals'] = array(
        'title' => 'Globals',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'global'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/globals/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'global'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/files'] = array(
        'title' => 'Files',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'file'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/files/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'file'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/classes'] = array(
        'title' => 'Classes and interfaces',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'class'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/classes/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'class'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/groups'] = array(
        'title' => 'Topics',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'group'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/groups/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'group'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/namespaces'] = array(
        'title' => 'Namespaces',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'namespace'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/namespaces/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'namespace'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

  }

  // Redirect 1.0 file links.
  $items['api/file/%menu_tail'] = array(
    'page callback' => 'api_file_redirect',
    'page arguments' => array(2),
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
    'file' => 'legacy.inc',
  );

  // Redirect 1.1 links.
  // Objects
  $items['api/function/%api_legacy_1_2_object'] =
  $items['api/function/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('function', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constant/%api_legacy_1_2_object'] =
  $items['api/constant/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('constant', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/global/%api_legacy_1_2_object'] =
  $items['api/global/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('global', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/group/%api_legacy_1_2_object'] =
  $items['api/group/%api_legacy_1_2_object/%'] = array(
    'load arguments' => array('group', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Default listings
  $items['api/functions'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/functions'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/files'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/constants'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/globals'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/groups'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Branch listings
  $items['api/functions/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('functions'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('files'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('constants'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('globals'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('groups'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/%api_legacy_1_2_listing'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Returns a list of projects with their default branches, for use in menus.
 *
 * Basically, we need to define a default branch for each project: the first
 * "preferred" branch with the correct core compatibility.
 */
function _api_make_menu_projects() {
  $branches = api_get_branches();
  if (!count($branches)) {
    return array();
  }

  $compatibility = variable_get('api_default_core_compatibility', '7.x');
  $projects = array();

  foreach ($branches as $branch) {
    if (!isset($projects[$branch->project])) {
      $projects[$branch->project] = array(
        'max branch' => $branch->branch_name,
        'use branch' => NULL,
      );
    }
    else {
      $projects[$branch->project]['max branch'] = max($projects[$branch->project]['max branch'], $branch->branch_name);
    }

    if ($branch->core_compatibility === $compatibility && $branch->preferred) {
      $projects[$branch->project]['use branch'] = $branch->branch_name;
    }
  }

  foreach (array_keys($projects) as $project) {
    if (is_null($projects[$project]['use branch'])) {
      $projects[$project]['use branch'] = $projects[$project]['max branch'];
    }
  }

  return $projects;
}

/**
 * Finds objects for old URLs and returns the new URL.
 *
 * @param $object_name
 *   Name of the object to find the URL of.
 * @param $object_type
 *   Type of object ('function', 'constant', etc.).
 * @param $branch_name
 *   Name of the branch to find the object in (across projects).
 *
 * @return
 *   First matching URL for this combination of object name, type, and branch
 *   name, or NULL if none is found.
 */
function api_legacy_1_2_object_load($object_name, $object_type, $branch_name) {
  foreach (api_get_branches_by_name($branch_name) as $branch) {
    $object = api_object_load($object_name, $branch, $object_type);
    if (isset($object)) {
      return api_url($object);
    }
  }
}

/**
 * Returns the current path to listing pages accessed with old URLs.
 *
 * @param $branch_name
 *   Name of the branch to redirect.
 * @param $type
 *   Type of listing page ('functions', etc.), or NULL for the home page.
 *
 * @return
 *   URL to redirect this listing to, in the default project.
 */
function api_legacy_1_2_listing_load($branch_name, $type = NULL) {
  $branch = api_get_branch_by_id();
  if (empty($branch_name)) {
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }
  if (isset($type)) {
    return 'api/' . $branch->project . '/' . $type . '/' . $branch_name;
  }
  else {
    return 'api/' . $branch->project . '/' . $branch_name;
  }
}

/**
 * Finds all branches matching a branch name, across projects.
 *
 * @param $branch_name
 *   Branch name to match. If empty, defaults to the default branch.
 *
 * @return
 *   Array of all branch objects with this name.
 */
function api_get_branches_by_name($branch_name) {
  $return = array();
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      return array();
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->branch_name === $branch_name) {
      $return[] = $branch;
    }
  }

  return $return;
}

/**
 * Loads a branch, given a project and branch name.
 *
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name. If not set, uses the
 *   default branch name.
 *
 * @return
 *   Object representing the branch, or NULL if there is no match.
 */
function api_get_branch_by_name($project, $branch_name) {
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->project === $project && $branch->branch_name === $branch_name) {
      return $branch;
    }
  }

  return NULL;
}

/**
 * Loads an API object for the menu router.
 *
 * Menu object load callback for %api_item in menu paths.
 *
 * @param $object_name
 *   The object name matching {api_documentation}.object_name.
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name.
 * @param $file_name
 *   The name of the file the object is in, with API_FILEPATH_SEPARATOR for path
 *   separators. We convert all API_FILEPATH_SEPARATOR_REPLACEMENTs back to
 *   API_FILEPATH_SEPARATORs to maintain the original file path information.
 *   (When a URL is created for a documentation object, all
 *   API_FILEPATH_SEPARATORs in the original file path are replaced with
 *   API_FILEPATH_SEPARATOR_REPLACEMENTs so that API_FILEPATH_SEPARATORs won't
 *   be interpreted as part the of URL.
 * @param $type
 *   API item type; one of function, constant, global, property, class,
 *   interface, or group.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_item_load($object_name, $project, $branch_name, $file_name, $type) {
  // Check type
  if (!in_array($type, array('function', 'constant', 'global', 'property', 'class', 'interface', 'group'))) {
    return FALSE;
  }

  // Load branch
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  // Load object
  $back_to_orig_filename = str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name);
  $doc_object = api_object_load($object_name, $branch, $type, $back_to_orig_filename);

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load($object_name, $branch, $type, str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name) );
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Implements hook_cron_queue_info().
 */
function api_cron_queue_info() {
  // Note that the order here is the order the queues will be invoked.
  return array(
    'api_branch_update' => array(
      'worker callback' => 'api_queue_update_branch',
      'time' => 30,
    ),
    'api_parse' => array(
      'worker callback' => 'api_queue_parse_file',
      'time' => 60,
    ),
    'api_node_delete' => array(
      'worker callback' => 'api_queue_node_delete',
      'time' => 15,
    ),
  );
}

/**
 * Loads an API file object.
 *
 * Menu object load callback for %api_filename in menu paths.
 *
 * API v 1.3 replaced all '/'s in the file path with '--' for the URL generated
 * for the file. We need to handle a URL with '--' (=
 * API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) and redirected it to the current,
 * correct URL.  We now convert all '/'s (= API_FILEPATH_SEPARATOR) to
 * API_FILEPATH_SEPARATOR_REPLACEMENT when a URL is created for a documentatio
 * object. Here we need to go back to the original filename and path.
 *
 * @param $file_name
 *   Name of the file to load.
 * @param $project
 *   Name of the project the file is in.
 * @param $branch_name
 *   Name of the branch the file is in.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_filename_load($file_name, $project, $branch_name) {
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  $doc_object = api_object_load(str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load(str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Loads a documentation object.
 *
 * @param $object_name_or_did
 *   The string object name or integer documentation ID to load.
 * @param $branch
 *   Branch object. Ignored if $object_name_or_did is an integer.
 * @param $object_type
 *   A string type, or array of strings: class, interface, function, etc.
 *   Can be omitted if $object_name_or_did is an integer.
 * @param $file_name
 *   Name of the file the object is in (if needed). Ignored if
 *   $object_name_or_did is an integer.
 *
 * @return
 *   Object with information about the matching documentation, or NULL if it
 *   does not exist.
 */
function api_object_load($object_name_or_did, $branch = NULL, $object_type = '', $file_name = NULL) {
  static $cache;

  if (!is_array($object_type)) {
    $object_type = array($object_type);
  }

  if (is_int($object_name_or_did)) {
    $key = $object_name_or_did;
  }
  else {
    $key = $object_name_or_did . ':' . implode('-', $object_type) . ':' . $branch->branch_id . ':' . $file_name;
  }

  // See if we have this cached.
  if (isset($cache[$key])) {
    return $cache[$key];
  }

  // We don't have a cached value. Prepare the query.

  // Set up the basic query.
  $query = db_select('api_documentation', 'ad');
  $ao = $query->leftJoin('api_overrides', 'ao', 'ao.did = ad.did');
  $query
    ->fields('ad')
    ->fields($ao, array('documented_did', 'overrides_did'));

  if (is_int($object_name_or_did)) {
    // Quick query on just the documentation ID.
    $query->condition('ad.did', $object_name_or_did);
  }
  else {
    $query
      ->condition('ad.object_type', $object_type)
      ->condition('ad.branch_id', $branch->branch_id)
      ->condition('ad.object_name', $object_name_or_did);
    if (!is_null($file_name)) {
      $query->condition('ad.file_name', $file_name);
    }
  }

  // Set up extra fields, depending on the object type.
  if (in_array('function', $object_type)) {
    $afunc = $query->leftJoin('api_function', 'afunc', 'afunc.did = ad.did');
    $query->fields($afunc, array('signature', 'parameters', 'return_value'));
  }
  elseif (in_array('file', $object_type)) {
    $afile = $query->leftJoin('api_file', 'afile', 'afile.did = ad.did');
    $query->fields($afile, array('modified', 'queued'));
  }

  // Set up field for the file's doc ID.
  $query->leftJoin('api_documentation', 'adfile', "adfile.file_name = ad.file_name AND adfile.object_type = 'file' AND adfile.branch_id = ad.branch_id");
  $query->addField('adfile', 'did', 'file_did');

  // Execute the query, and store in cache if it's successful.
  $query = $query->range(0, 1);
  $result = $query->execute();
  $result_object = NULL;
  foreach ($result as $result_object) {
    // Grab documentation from documented parent.
    if (!empty($result_object->documented_did) && $result_object->documented_did !== $result_object->did) {
      $documented_object = api_object_load((int) $result_object->documented_did, $branch, $object_type);
      if (isset($documented_object)) {
        foreach (array('documentation', 'parameters', 'return_value', 'see', 'throws', 'var') as $member) {
          $result_object->$member = $documented_object->$member;
        }
      }
    }
    // Store in the cache.
    $cache[$key] = $result_object;
    return $result_object;
  }

  return NULL;
}

/**
 * Loads namespace and use information for a file.
 *
 * @param $file_did
 *   Documentation ID of the file.
 *
 * @return
 *   Associative array with elements:
 *   - namespace: Name of the namespace for this file (could be '').
 *   - use_alias: Associative array of use statement class aliases. Keys are
 *     the alias names, and values are the fully namespaced class names.
 */
function api_get_namespace_info($file_did = NULL) {
  static $cache = array();

  $ret = array('namespace' => '', 'use_alias' => array());

  if (!isset($file_did) || !$file_did) {
    return $ret;
  }

  if (isset($cache[$file_did])) {
    return $cache[$file_did];
  }

  $values = db_select('api_namespace', 'n')
    ->condition('did', $file_did)
    ->condition('class_name', '', '<>')
    ->fields('n', array('object_type', 'class_alias', 'class_name'))
    ->execute();
  foreach ($values as $info) {
    // Start namespaces with backslash.
    $name = $info->class_name;
    if (drupal_substr($name, 0, 1) != '\\') {
      $name = '\\' . $name;
    }

    if ($info->object_type == 'namespace') {
      $ret['namespace'] = $name;
    }
    else {
      $ret['use_alias'][$info->class_alias] = $name;
    }
  }

  $cache[$file_did] = $ret;

  return $ret;
}

/**
 * Figures out the full class name of a class, with namespaces.
 *
 * @param $name
 *   The name as it appears, which could include a namespace, and might or
 *   might not start with a backslash if it does.
 * @param $namespace
 *   The namespace for the file the name appears in.
 * @param $use_aliases
 *   Associative array of alias name to full name for use statements in the
 *   file the name appears in.
 *
 * @return
 *   Fully-qualified name of the class, starting with a backslash.
 */
function api_full_classname($name, $namespace = array(), $use_aliases = array()) {

  // Break off the class name from the rest.
  $classname = $name;
  $suffix = '';

  $pos = strpos($name, '::');
  if ($pos === FALSE) {
    $pos = strpos($name, '->');
  }
  if ($pos !== FALSE) {
    $classname = substr($name, 0, $pos);
    $suffix = substr($name, $pos);
  }

  if (in_array($classname, array('self', 'static', 'parent', 'this'))) {
    // Skip these keywords.
    return $name;
  }

  // See if there is an alias for this class name, or if we should prepend
  // the file's namespace.
  if (isset($use_aliases[$classname])) {
    // This class was aliased.
    $classname = $use_aliases[$classname];
  }
  elseif (strpos($classname, '\\') === FALSE) {
    // There was no alias, and the classname did not have a namespace in it.
    $classname = $namespace . '\\' . $classname;
  }

  // Make sure to start with a backslash, no matter what.
  if (strpos($classname, '\\') !== 0) {
    $classname = '\\' . $classname;
  }

  return $classname . $suffix;
}

/**
 * Implements hook_permission().
 */
function api_permission() {
  return array(
    'access API reference' => array(
      'title' => t('Access API reference pages'),
    ),
    'administer API reference' => array(
      'title' => t('Administer API reference'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function api_theme() {
  return array(
    'api_defined' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-defined',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_defined'),
    ),
    'api_functions' => array(
      'variables' => array(
        'functions' => array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-functions',
    ),
    'api_function_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'signatures' => NULL,
        'documentation' => NULL,
        'parameters' => NULL,
        'return' => NULL,
        'related_topics' => NULL,
        'call_links' => array(),
        'code' => NULL,
        'see' => NULL,
        'throws' => NULL,
        'class' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-function-page',
      'file' => 'api.theme.inc',
    ),
    'api_constant_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'class' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-constant-page',
      'file' => 'api.theme.inc',
    ),
    'api_global_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-global-page',
      'file' => 'api.theme.inc',
    ),
    'api_property_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'var' => NULL,
        'class' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-property-page',
      'file' => 'api.theme.inc',
    ),
    'api_class_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'implements' => NULL,
        'hierarchy' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-class-page',
      'file' => 'api.theme.inc',
    ),
    'api_file_page' => array(
      'variables' => array(
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'see' => NULL,
        'related_topics' => NULL,
        'defined' => '',
        'call_links' => array(),
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-file-page',
      'file' => 'api.theme.inc',
    ),
    'api_group_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-group-page',
      'file' => 'api.theme.inc',
    ),
    'api_branch_default_page' => array(
      'variables' => array(
        'branch' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-branch-default-page',
    ),
    'api_function_reference_link' => array(
      'variables' => array(
        'type' => '',
        'count' => 0,
        'function' => (object) array(),
        'override_text' => '',
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'file' => 'api.theme.inc',
    ),
    'api_class_section' => array(
      'variables' => array(
        'class' => NULL,
        'branch' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-class-section',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_class_section'),
    ),
    'api_views_view_dl_list' => array(
      'variables' => array(
      ),
      'template' => 'api-views-view-dl-list',
      'path' => drupal_get_path('module', 'api') . '/templates',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_views_view_dl_list'),
    ),
  );
}

/**
 * Saves or returns a string to use for the HTML page title.
 *
 * @param $title
 *   If provided, stores this as the page title string.
 *
 * @return
 *   The previously-set page title, or NULL if it has not been set during
 *   this page load.
 */
function api_set_html_page_title($title = NULL) {
  static $page_title = NULL;

  if (isset($title)) {
    $page_title = $title;
  }

  return $page_title;
}

/**
 * Implements hook_preprocess_HOOK() for html.tpl.php.
 *
 * Sets the page title if it's an API module page.
 */
function api_preprocess_html(&$variables) {
  $title = api_set_html_page_title();
  if ($title) {
    $variables['head_title'] = $title;
  }
}

/**
 * Implements hook_init().
 *
 * Adds CSS and JavaScript for the search auto-complete. Adds OpenSearch
 * autodiscovery links. Redirects nodes of type 'api' to the correct URL.
 */
function api_init() {
  $branch = api_get_active_branch();

  // If we happen to be on an API node page, redirect.
  if (($node = menu_get_object('node')) && $node->type == 'api') {
    $result = db_select('api_documentation', 'd')
      ->fields('d', array('branch_id', 'object_type', 'file_name', 'object_name'))
      ->condition('did', $node->nid)
      ->range(0, 1)
      ->execute()
      ->fetchObject();
    drupal_goto(api_url($result));
  }

  // Add OpenSearch autodiscovery links.
  $weight = 100;
  foreach (api_get_branches() as $branch) {
    $title = t('Drupal API @branch', array('@branch' => $branch->title));
    $url = url('api/opensearch/' . $branch->project . '/' . $branch->branch_name, array('absolute' => TRUE));
    drupal_add_html_head(array(
        '#tag' => 'link',
        '#weight' => $weight,
        '#attributes' => array(
          'href' => $url,
          'title' => $title,
          'rel' => 'search',
          'type' => 'application/opensearchdescription+xml',
        ),
      ), $title);
    $weight++;
  }
}

/**
 * Implements hook_query_TAG_alter() for node_access queries.
 *
 * Excludes nodes of type 'api' from node queries.
 */
function api_query_node_access_alter($query) {
  // Find all instances of the 'node' table, and make sure they exclude API
  // nodes.
  $tables = $query->getTables();
  foreach ($tables as $alias => $table_info) {
    if (is_array($table_info) && isset($table_info['table']) && $table_info['table'] == 'node') {
      $or = db_or()
        ->isNull($alias . '.type')
        ->condition($alias . '.type', 'api', '<>');
      $query->condition($or);
    }
  }
}

/**
 * Implements hook_block_info().
 */
function api_block_info() {
  return array(
    'api-search' => array(
      'info' => t('API search'),
      // This needs to be non-cached as it's a form with a form
      // token in it, and they can't be stale.
      'cache' => DRUPAL_NO_CACHE,
    ),
    'navigation' => array(
      'info' => t('API navigation'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function api_block_view($delta) {
  $branch = api_get_active_branch();

  switch ($delta) {
    case 'api-search':
      if (user_access('access API reference') && !empty($branch)) {
        return array(
          'subject' => t('Search @branch', array('@branch' => $branch->title)),
          'content' => drupal_get_form('api_search_form', $branch),
        );
      }
      return;

    case 'navigation':
      if (user_access('access API reference') && !empty($branch)) {
        // Figure out if this is the default branch for this project, the same
        // way the menu system decides.

        $default_branch = api_get_branch_by_id();
        $projects = _api_make_menu_projects();
        $is_default = ($branch->branch_name === $projects[$branch->project]['use branch']);
        $suffix = ($is_default) ? '' : '/' . $branch->branch_name;

        $links = array();
        $links[] = l($branch->title, 'api/' . $branch->project . $suffix);
        $counts = api_listing_counts($branch);
        if ($counts['constants'] > 0) {
          $links[] = l(t('Constants'), 'api/' . $branch->project . '/constants' . $suffix);
        }
        if ($counts['classes'] > 0) {
          $links[] = l(t('Classes'), 'api/' . $branch->project . '/classes' . $suffix);
        }
        if ($counts['files'] > 0) {
          $links[] = l(t('Files'), 'api/' . $branch->project . '/files' . $suffix);
        }
        if ($counts['functions'] > 0) {
          $links[] = l(t('Functions'), 'api/' . $branch->project . '/functions' . $suffix);
        }
        if ($counts['globals'] > 0) {
          $links[] = l(t('Globals'), 'api/' . $branch->project . '/globals' . $suffix);
        }
        if ($counts['groups'] > 0) {
          $links[] = l(t('Topics'), 'api/' . $branch->project . '/groups' . $suffix);
        }
        if ($counts['namespaces'] > 0) {
          $links[] = l(t('Namespaces'), 'api/' . $branch->project . '/namespaces' . $suffix);
        }

        return array(
          'subject' => t('API Navigation'),
          'content' => theme('item_list', array('items' => $links)),
        );
      }
      return;
  }
}

/**
 * Counts items by type for a branch.
 *
 * @param $branch
 *   Object representing the branch to count.
 *
 * @return
 *   Associative array where the keys are the type of listing ('functions',
 *   'classes', etc.) and the values are the count of how many there are in
 *   that listing for the given branch.
 */
function api_listing_counts($branch) {

  static $cached_counts = array();

  // Check the cache.
  $key = $branch->branch_name . $branch->branch_id;
  if (isset($cached_counts[$key])) {
    return $cached_counts[$key];
  }

  $return = array(
    'groups' => 0,
    'classes' => 0,
    'functions' => 0,
    'constants' => 0,
    'globals' => 0,
    'files' => 0,
    'namespaces' => 0,
  );

  // These queries mirror what is done in api_page_listing().
  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('object_type', 'group')
    ->groupBy('branch_id');
  $query->addExpression('COUNT(*)', 'num');
  $return['groups'] = $query
    ->execute()
    ->fetchField();

  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('namespace', '', '<>')
    ->groupBy('namespace');
  $query->addExpression('COUNT(*)', 'num');
  $return['namespaces'] = $query
    ->execute()
    ->fetchField();

  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('object_type', array('class', 'interface'))
    ->condition('class_did', 0)
    ->groupBy('branch_id');
  $query->addExpression('COUNT(*)', 'num');
  $return['classes'] = $query
    ->execute()
    ->fetchField();

  foreach (array('function', 'constant', 'global', 'file') as $type) {
    $query = db_select('api_documentation', 'ad')
      ->condition('branch_id', $branch->branch_id)
      ->condition('object_type', $type)
      ->condition('class_did', 0)
      ->groupBy('branch_id');
    $query->addExpression('COUNT(*)', 'num');
    $return[$type . 's'] = $query
      ->execute()
      ->fetchField();
  }

  $cached_counts[$key] = $return;
  return $return;
}

/**
 * Implements hook_filter_info().
 */
function api_filter_info() {
  return array(
    'api_filter' => array(
      'title' => t('API filter'),
      'description' => t('Add links to API objects, like theme() or theme.inc.'),
      'process callback' => 'api_filter_documentation'
    ),
  );
}

/**
 * Implements hook_forms().
 *
 * Since the 'api' content type is hidden, do what comment_forms() does so
 * that the comment form will work.
 */
function api_forms() {
  $forms = array();
  $forms['comment_node_api_form']['callback'] = 'comment_form';
  return $forms;
}

/**
 * Constructs a link to an API object page.
 *
 * Constructs a URL for an object, replacing any API_FILEPATH_SEPARATOR in a
 * file path with API_FILEPATH_SEPARATOR_REPLACEMENT.
 *
 * @param $object
 *   An API object with object_type, object_name, branch_id, and file_name
 *   properties.
 * @param $file
 *   TRUE links to the objects containing file, FALSE links to the object
 *   itself.
 *
 * @return
 *   A URL string, or an empty string if there was a problem.
 */
function api_url($object, $file = FALSE) {
  $branch = api_get_branch_by_id($object->branch_id);
  if (!$branch) {
    return '';
  }

  if ($file) {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  elseif ($object->object_type === 'file') {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->object_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  else {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $object->object_type . '/' . $object->object_name . '/' . $branch->branch_name;
  }
}

/**
 * Constructs a link to an API namespace page.
 *
 * Constructs a URL for a namespace, replacing any API_NAMESPACE_SEPARATOR in a
 * file path with API_FILEPATH_SEPARATOR_REPLACEMENT.
 *
 * @param $branch_id
 *   ID of the branch to make the link in.
 * @param $namespace
 *   Namespace to make the link for.
 *
 * @return
 *   A URL string, or an empty string if there was a problem.
 */
function api_namespace_url($branch_id, $namespace) {
  $branch = api_get_branch_by_id($branch_id);
  if (!$branch) {
    return '';
  }

  $replaced_string = str_replace(API_NAMESPACE_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $namespace);
  return 'api/' . $branch->project . '/namespace/' . $replaced_string . '/' . $branch->branch_name;
}

/**
 * Saves an API branch.
 *
 * @param $branch
 *   A branch object.
 */
function api_save_branch($branch) {
  $branch->data = serialize($branch->data);
  // Update the queue valid timestamp for this branch so that old queue jobs
  // are invalid.
  $branch->queue_valid = time();
  // Update the last updated timestamp for this branch so that it will be
  // updated as soon as possible.
  $branch->last_updated = 0;

  if (empty($branch->branch_id)) {
    drupal_write_record('api_branch', $branch);
  }
  else {
    drupal_write_record('api_branch', $branch, 'branch_id');

    // We've just updated a files branch, so we need to mark all of the files
    // that were in the parse queue so that they are re-queued next time
    // we scan this branch for files.
    $query = db_select('api_file', 'f')
      ->fields('f', array('did'))
      ->condition('queued', 0, '<>');
    $query->leftJoin('api_documentation', 'd', 'f.did = d.did');
    $dids = $query->condition('d.branch_id', $branch->branch_id)
      ->execute()
      ->fetchCol();
    if (count($dids)) {
      db_update('api_file')
        ->condition('did', $dids)
        ->fields(array('queued' => 0))
        ->execute();
    }
  }

  api_reset_branches();
}

/**
 * Saves an API PHP branch.
 *
 * @param $branch
 *   A PHP branch object.
 */
function api_save_php_branch($branch) {
  $branch->data = serialize($branch->data);
  if (empty($branch->branch_id)) {
    drupal_write_record('api_php_branch', $branch);
  }
  else {
    drupal_write_record('api_php_branch', $branch, 'branch_id');
  }

  api_get_php_branches(TRUE);
}

/**
 * Saves an API project.
 *
 * @param $project
 *   A project to save.
 * @param $old_name
 *   If the project_name (primary key) field is changing, provide the previous
 *   name.
 */
function api_save_project($project, $old_name = '') {
  if (!strlen($old_name)) {
    $old_name = $project->project_name;
  }
  db_delete('api_project')
    ->condition('project_name', $old_name)
    ->execute();
  drupal_write_record('api_project', $project);

  if ($old_name != $project->project_name) {
    // Update existing branches to the new name.
    db_update('api_branch')
      ->condition('project', $old_name)
      ->fields(array('project' => $project->project_name))
      ->execute();
  }

  // See if our current default project is valid, and reset if not.
  $default = variable_get('api_default_project', '');
  if (!api_project_exists($default)) {
    variable_set('api_default_project', $project->project_name);
  }

  api_reset_branches();
}

/**
 * Checks to see if a project exists.
 *
 * @param project_name
 *   Name to check for.
 *
 * @return
 *   TRUE if the project exists, and FALSE if not.
 */
function api_project_exists($project_name) {
  $result = db_select('api_project', 'p')
    ->fields('p')
    ->condition('project_name', $project_name)
    ->execute()
    ->fetchObject();
  return isset($result->project_name) && $result->project_name == $project_name;
}

/**
 * Fixes up branches, after one is updated, added, or deleted.
 */
function api_reset_branches() {
  // Recalculate the default branch.
  $branches = api_get_branches(TRUE);
  $project = variable_get('api_default_project', '');
  $version = variable_get('api_default_core_compatibility', '');
  foreach ($branches as $branch) {
    if ($branch->project == $project && $branch->preferred && $branch->core_compatibility == $version) {
      variable_set('api_default_branch', $branch->branch_id);
      break;
    }
  }

  // Reset the branch lists.
  $branches = api_get_branches(TRUE);
  api_get_branch_names(TRUE);

  // Reweight all branches.
  usort($branches, 'api_branch_sort');
  $weight = 0;
  foreach ($branches as $branch) {
    $branch->weight = $weight;
    $weight += 1;
    drupal_write_record('api_branch', $branch, 'branch_id');
  }

  // Rebuild the menu system.
  menu_rebuild();
}

/**
 * Sorts branches by project, version number, and branch name.
 *
 * Callback for usort() within api_reset_branches().
 */
function api_branch_sort($a, $b) {
  // Sort by project.
  if ($a->project != $b->project) {
    $default_project = variable_get('api_default_project', '');
    // If one of a or b is in the default project and the other isn't, that
    // one is preferred.
    if ($a->project == $default_project) {
      return -1;
    }
    if ($b->project == $default_project) {
      return 1;
    }

    // If one is core and the other isn't, that's preferred.
    if ($a->project_type == 'core' && $b->project_type != 'core') {
      return -1;
    }
    if ($a->project_type != 'core' && $b->project_type == 'core') {
      return 1;
    }

    // Otherwise, sort alphabetically.
    return strcasecmp($a->project, $b->project);
  }

  // Sort by core compatibility.
  if ($a->core_compatibility != $b->core_compatibility) {
    $default_version = variable_get('api_default_core_compatibility', '');

    // If one of a or b is in the default compatibility and the other isn't,
    // that one is preferred.
    if ($a->core_compatibility == $default_version) {
      return -1;
    }
    if ($b->core_compatibility == $default_version) {
      return 1;
    }

    // Otherwise, sort by version.
    $result = version_compare($a->core_compatibility, $b->core_compatibility);
  }

  // Sort by preferred (preferred over not preferred within one project and
  // core compatibility).
  if ($a->preferred && !$b->preferred) {
    return -1;
  }
  if ($b->preferred && !$a->preferred) {
    return 1;
  }

  // If all else fails, just do alphabetical.
  return strcasecmp($a->branch_name, $b->branch_name);
}

/**
 * Returns the currently active branch object.
 */
function api_get_active_branch() {
  static $branch;

  if (!isset($branch)) {
    $item = menu_get_item();
    $branches = api_get_branches();
    $branch_names = api_get_branch_names();
    $default_branch = variable_get('api_default_branch', NULL);

    if (isset($item['page_arguments'][0]->branch_id)) {
      $branch = $branches[$item['page_arguments'][0]->branch_id];
    }
    elseif (isset($item['page_arguments'][0]->branch_name)) {
      $branch = $item['page_arguments'][0];
    }
    elseif ($item['path'] == 'api/%/namespace/%/%') {
      $project = $item['page_arguments'][0];
      $branch_name = $item['page_arguments'][1];
      $branch = api_get_branch_by_name($project, $branch_name);
    }
    elseif (strpos($item['path'], 'api/search') === 0 && isset($branch_names[$item['page_arguments'][0]])) {
      // This is a search page for a particular branch. Figure out what project
      // it corresponds to, using the default project if possible
      foreach ($branches as $possible_branch) {
        if ($possible_branch->project === $branches[$default_branch]->project && $possible_branch->branch_name === $item['page_arguments'][0]) {
          // Best case, this is a branch on the default project.
          $branch = $possible_branch;
          break;
        }
        elseif ($possible_branch->branch_name === $item['page_arguments'][0]) {
          // Second-best case, this at least matches. Keep looking.
          $branch = $possible_branch;
        }
      }
    }

    // If all else fails, use the default branch.
    if (!isset($branch)) {
      if (!is_null($default_branch) && isset($branches[$default_branch])) {
        $branch = $branches[$default_branch];
      }
      else {
        $branch = NULL;
      }
    }
  }

  return $branch;
}

/**
 * Form constructor for the API search form.
 *
 * @param $branch
 *   Object representing the branch to build the search form for.
 *
 * @see api_search_form_submit()
 */
function api_search_form($form, $form_state, $branch) {
  $form['#attributes']['class'] = 'api-search-form';
  $form['#branch'] = $branch;

  $form['search'] = array(
    '#title' => t('Function, file, or topic'),
    '#description' => t('Partial match search is supported'),
    '#type' => 'textfield',
    '#default_value' => '',
    '#required' => TRUE,
    '#attributes' => array('class' => array('api-search-keywords')),
    '#autocomplete_path' => 'api/search/autocomplete/' . $branch->branch_id,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );

  return $form;
}

/**
 * Form submission handler for api_search_form().
 */
function api_search_form_submit($form, &$form_state) {
  $branch = $form['#branch'];
  $form_state['redirect'] = 'api/' . $branch->project . '/' . $branch->branch_name . '/search/' . $form_state['values']['search'];
}

/**
 * Implements hook_cron().
 */
function api_cron() {
  // Do not do cron unless there is at least one branch, or if the
  // API admin page has been visited at least once.
  $doit = variable_get('api_do_cron', 0);
  if (!$doit) {
    $doit = (count(api_get_branches()) > 0);
  }

  if ($doit) {
    module_load_include('inc', 'api', 'parser');
    api_update_all_branches();
  }
}

/**
 * Turns function names into links in code.
 *
 * @param $code
 *   PHP code to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class the code is in (if any).
 *
 * @return
 *   Code with function names formatted as links.
 */
function api_link_code($code, $branch, $file_did = NULL, $class_did = NULL) {
  return _api_link_documentation($code, $branch, $file_did, $class_did, array('code hook name', 'code alter hook name', 'code theme hook name', 'code function', 'code member', 'code string', 'yaml reference', 'code global', 'code class'));
}

/**
 * Turns function names into links in documentation.
 *
 * @param $documentation
 *   Documentation to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE. Otherwise, just try to link words with backslashes in them.
 * @param $aggressive_topics
 *   For use in @see only, if TRUE try linking every paragraph as a topic name,
 *   if it didn't match as something else first.
 *
 * @return
 *   Documentation with function names formatted as links.
 */
function api_link_documentation($documentation, $branch, $file_did = NULL, $class_did = NULL, $aggressive_classes = FALSE, $aggressive_topics = FALSE) {

  $filter = new stdClass();
  $filter->callback = '_filter_url';
  $filter->settings = array( 'filter_url_length' => 72);

  return _filter_url(api_filter_documentation($documentation, $branch, $file_did, $class_did, $aggressive_classes, $aggressive_topics), $filter);
}

/**
 * Turns function names into links for a text filter.
 *
 * This is the process callback for the API filter supplied by api_filter().
 * It turns function names into links on output, using the currently active
 * branch.
 *
 * @param $text
 *   Text to filter.
 * @param $branch
 *   Branch object to use for links.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE. Otherwise, just try to link words with backslashes in them.
 * @param $aggressive_topics
 *   For use in @see only, if TRUE try linking every paragraph as a topic name,
 *   if it didn't match as something else first.
 *
 * @return
 *   Text with function names turned into links.
 */
function api_filter_documentation($text, $branch = NULL, $file_did = NULL, $class_did = NULL, $aggressive_classes = FALSE, $aggressive_topics = FALSE) {
  if (is_null($branch)) {
    $branch = api_get_active_branch();
  }

  // Start with the code-related stages, for the @code sections. Follow with
  // the basic documentation stages.
  $stages = array('code hook name', 'code alter hook name', 'code theme hook name', 'code function', 'code member', 'code string', 'code global', 'code class', 'tags', 'link', 'function');

  if ($aggressive_topics) {
    // Look for topics before classes, constants, and files.
    $stages[] = 'topic';
  }
  $stages[] = 'file';
  $stages[] = 'constant';
  if ($aggressive_classes) {
    $stages[] = 'class';
  }
  else {
    $stages[] = 'definite class';
  }

  // Remove escaping from \@.
  return preg_replace('!\\\@!', '@', _api_link_documentation($text, $branch, $file_did, $class_did, $stages));
}

/**
 * Recursive internal callback for turning function names into links in code.
 *
 * @param $documentation
 *   PHP code to scan for function names.
 * @param $branch
 *   Branch to make the links in.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @stages
 *   Array of stages to process.
 *
 * @return
 *   Code with function names formatted as links.
 *
 * @see api_link_code()
 * @see api_link_name()
 */
function _api_link_documentation($documentation, $branch, $file_did = NULL, $class_did = NULL, $stages = array()) {

  $stage = array_shift($stages);

  $callback_match = 'api_link_name';
  $prepend = '';
  $append = '';
  $prepend_if_not_found = NULL;
  $use_php = TRUE;
  $type = '';
  $pattern = '';
  $continue_matching = FALSE;

  switch ($stage) {
    case 'tags':
      // Find HTML tags, not filtered.
      $callback_match = NULL;
      $pattern = '/(<[^>]+?' . '>)/';
      break;

    case 'link':
      // Find @link.
      $pattern = '/' . API_RE_TAG_START . 'link\s+(.*)\s+' . API_RE_TAG_START . 'endlink/U';
      $callback_match = 'api_link_link';
      break;

    case 'function':
      // Find function names, which are preceded by white space and followed by
      // '('.
      $append = '(';
      $pattern = '!' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_FUNCTION_IN_TEXT . ')\(!';
      $type = 'function';
      break;

    case 'code function':
      // Find function names in marked-up code.
      $pattern = '!<span class="php-function-or-constant">(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      $type = 'function_or_constant';
      break;

    case 'code class':
      // Find class names in marked-up code, as constructors.
      $pattern = '!<span class="php-function-or-constant">(' . API_RE_CLASS_NAME_TEXT . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      $type = 'class';
      break;

    case 'code global':
      // Find global variable names in marked-up code.
      $pattern = '!<span class="php-keyword">global</span> <span class="php-variable">\$(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!';
      $prepend = '<span class="php-keyword">global</span> <span class="php-variable">$';
      $append = '</span>';
      $type = 'global';
      break;

    case 'code string':
      // Find potential function names (callback strings) in marked-up code.
      // These are all strings that are legal function names, where the function
      // name is put into something like a hook_menu() page callback as a
      // string.
      $pattern = '!<span class="php-string">\'(' . DRUPAL_PHP_FUNCTION_PATTERN . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'function';
      break;

    case 'yaml reference':
      // Find potential function names (callback strings) in marked-up YAML
      // code. These are all strings that are legal function names, possibly
      // with namespaces and class names, possibly in quotes.
      $pattern = '!<span class="yaml-reference">(' . API_RE_FUNCTION_IN_TEXT . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      $prepend_if_not_found = '';
      $append_if_not_found = '';
      $use_php = FALSE;
      $type = 'yaml_reference';
      break;

    case 'code hook name':
      // Find potential hook names in marked-up code. These are strings that
      // are legal function names, which were found in parsing to be inside
      // module_implements() and related functions.
      $pattern = '!<span class="php-string potential-hook">\'(' . API_RE_HOOK_NAME . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'hook';
      break;

    case 'code alter hook name':
      // Works like 'code hook name' above, but for alter hooks.
      $pattern = '!<span class="php-string potential-alter">\'(' . API_RE_HOOK_NAME . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'alter hook';
      break;

    case 'code theme hook name':
      // Works like 'code hook name' above, but for theme hooks.
      $pattern = '!<span class="php-string potential-theme">\'(' . DRUPAL_PHP_FUNCTION_PATTERN . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $use_php = FALSE;
      $type = 'theme';
      break;

    case 'code member':
      // Works like 'code hook name' above, but for class members.
      $callback_match = 'api_link_member_name';
      $pattern = '!(<span class="php-function-or-constant [^"]+ member-of-[^"]+">' . DRUPAL_PHP_FUNCTION_PATTERN . '</span>)!';
      break;

    case 'file':
      // Find file names, which are an arbitrary number of strings joined with
      // '.'
      $pattern = '%' . API_RE_WORD_BOUNDARY_START . API_RE_FILENAME . API_RE_WORD_BOUNDARY_END . '%';
      $type = 'file';
      break;

    case 'constant':
      // Find constants, UPPERCASE_LETTERS_WITH_UNDERSCORES.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '([A-Z_]+)' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'constant';
      break;

    case 'class':
      // Find class names, which have a capital letter.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_CLASS_NAME_TEXT . ')' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'class';
      break;

    case 'definite class':
      // Find definite class names, which have a backslash.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_DEFINITE_CLASS_NAME_TEXT . ')' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'class';
      break;

    case 'topic':
      // Find topic/group names.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_GROUP_NAME . ')' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'group';
      // Patterns that match topics might also match other objects.
      // keep looking for matches after running the linker.
      $continue_matching = TRUE;
      break;
  }

  if (count($stages) > 0) {
    $callback = '_api_link_documentation';
  }
  else {
    $callback = NULL;
  }

  return api_split($pattern, $documentation, $callback_match, array($branch, $prepend, $append, $file_did, $class_did, NULL, NULL, $use_php, $prepend_if_not_found, NULL, $type), $callback, array($branch, $file_did, $class_did, $stages), $continue_matching);
}

/**
 * Splits a string using a regular expression and processes using callbacks.
 *
 * @param $pattern
 *   The regular expression to match for splitting.
 * @param $subject
 *   The string to process.
 * @param $callback_match
 *   Function name to be called for text which matches $pattern. The first
 *   argument will be the parenthesized expression in the pattern. Should
 *   return a string. NULL to pass the text through unchanged.
 * @param $callback_match_arguments
 *   An array of additional parameters for $callback_match.
 * @param $callback
 *   Function name to be called for text which does not match $pattern. The
 *   first argument will be the text. Should return a string. NULL to pass the
 *   text through unchanged.
 * @param $callback_arguments
 *   An array of additional parameters for $callback.
 * @param $continue_matching
 *   If TRUE, call $callback again on the matched text if it is left unchanged
 *   by its callback.
 *
 * @return
 *   The original string, with both matched and unmatched portions filtered by
 *   the appropriate callbacks.
 */
function api_split($pattern, $subject, $callback_match = NULL, $callback_match_arguments = array(), $callback = NULL, $callback_arguments = array(), $continue_matching = FALSE) {
  $return = '';
  $matched = FALSE;
  foreach (preg_split($pattern . 'sm', $subject, -1, PREG_SPLIT_DELIM_CAPTURE) as $part) {
    if ($matched) {
      if (is_null($callback_match)) {
        $return .= $part;
      }
      else {
        $new_text = call_user_func_array($callback_match, array_merge(array($part), $callback_match_arguments));

        if ($new_text == $part && $continue_matching) {
          $new_text = call_user_func_array($callback, array_merge(array($part), $callback_arguments));
        }
        $return .= $new_text;
      }
    }
    else {
      if (is_null($callback)) {
        $return .= $part;
      }
      else {
        $return .= call_user_func_array($callback, array_merge(array($part), $callback_arguments));
      }
    }
    $matched = !$matched;
  }
  return $return;
}

/**
 * Links an object name to its documentation.
 *
 * @param $name
 *   Object name to link to.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   (unused) Documentation ID of the class this is part of (if any).
 * @param $text
 *   Link text. If omitted, uses $name.
 * @param $is_link
 *   TRUE if this was inside a @link.
 * @param $use_php
 *   TRUE if links to PHP functions should be made; FALSE if only Drupal
 *   objects.
 * @param $prepend_if_not_found
 *   Text to prepend if object is not found (defaults to $prepend).
 * @param $append_if_not_found
 *   Text to append if object is not found (defaults to $append).
 * @param $type
 *   The type of information $name represents. Possible values:
 *   - '': (default) $name is a normal object name.
 *   - 'hook': $name is a hook name.
 *   - 'alter hook': $name is an alter hook name.
 *   - 'theme': $name is a theme hook name.
 *   - 'function': $name is specifically a function ('file', 'constant', etc.
 *     also are supported).
 *   - 'function_or_constant': $name is either a function, constant, or class.
 *   - 'group': $name is a group/topic identifier.
 *   - 'global': $name is a global variable.
 *   - 'yaml_reference': $name is the possibly namespaced name of a function or
 *     method, possibly in single or double quotes (in a YAML file).
 *
 * @return
 *   The text as a link to the object page.
 */
function api_link_name($name, $branch, $prepend = '', $append = '', $file_did = NULL, $class_did = NULL, $text = NULL, $is_link = FALSE, $use_php = TRUE, $prepend_if_not_found = NULL, $append_if_not_found = NULL, $type = '') {

  if (is_null($text)) {
    $text = $name;
  }
  $name = trim($name);

  if ($type == 'yaml_reference') {
    // Trim off quotes and match as a function name.
    $name = trim($name, '"\'');
    $type = 'function';
  }

  // If we get here, we're looking to match some kind of documentation object.
  $link = _api_make_match_link($name, $text, $type, $is_link, $branch, $file_did);
  if ($link) {
    return $prepend . $link . $append;
  }

  // If we get here, there wasn't a match. Try PHP functions.
  if ($use_php) {
    $query = db_select('api_php_documentation', 'd')
      ->fields('d', array('object_name', 'documentation'));
    $b = $query->innerJoin('api_php_branch', 'b', "b.branch_id = d.branch_id");
    $query
      ->fields($b, array('data'))
      ->condition('d.object_type', 'function')
      ->condition('d.object_name', $name);
    $result = $query->execute();
    foreach ($result as $info) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($info->object_name != $name) {
        continue;
      }

      $data = unserialize($info->data);
      $link = strtr($data['path'], array('!function' => $name));
      return $prepend . l($text, $link, array('attributes' => array('title' => api_entity_decode($info->documentation), 'class' => array('php-manual')))) . $append;
    }
  }

  // If this is not a core branch, try matching in the core branch, and in
  // others with the same core compatibility.
  $core_branch = api_find_core_branch($branch);
  if ($core_branch && $core_branch->branch_id != $branch->branch_id) {
    $link = _api_make_match_link($name, $text, $type, $is_link, $core_branch, $file_did);
    if ($link) {
      return $prepend . $link . $append;
    }

    $link = _api_make_match_link($name, $text, $type, $is_link, NULL, $file_did, $branch->core_compatibility);
    if ($link) {
      return $prepend . $link . $append;
    }
  }

  // If we get here, there still wasn't a match, so return non-linked text.
  if (isset($prepend_if_not_found)) {
    $prepend = $prepend_if_not_found;
  }
  if (isset($append_if_not_found)) {
    $append = $append_if_not_found;
  }

  return $prepend . $text . $append;
}

/**
 * Finds matches for an object name in a branch and makes a link.
 *
 * @param $name
 *   Name to match (text found in the code or documentation).
 * @param $text
 *   Text to put in the link.
 * @param $type
 *   Type of object to match (see api_link_name() for options).
 * @param $try_link
 *   If TRUE, try making links as if this is to a topic or file first.
 * @param $branch
 *   Object representing the branch to search. If NULL, use core compatibility
 *   instead.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant. Ignored if $branch is not set.
 * @param $core_compatibility
 *   If $branch is NULL, search all branches with this core compatibility.
 *
 * @return
 *   Link to either a single matching object or a search if multiple matches
 *   exist; if there are no matches, FALSE.
 */
function _api_make_match_link($name, $text, $type, $try_link = FALSE, $branch = NULL, $file_did = NULL, $core_compatibility = '') {

  if ($try_link) {
    // Before trying standard matches, see if this is a link to a group/topic.
    $link = _api_make_match_link($name, $text, 'group', FALSE, $branch);
    if ($link) {
      return $link;
    }

    // See if it could be a file name being linked.
    $link = _api_make_match_link($name, $text, 'file', FALSE, $branch);
    if ($link) {
      return $link;
    }
  }

  // Now do the standard linking tries.
  // Build a query to find the matches.
  $query = db_select('api_documentation', 'ad')
    ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'));
  $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
  $query->fields('b', array('branch_name', 'preferred', 'project'));
  if (is_null($branch)) {
    $query->condition('b.core_compatibility', $core_compatibility);
  }
  else {
    $query->condition('ad.branch_id', $branch->branch_id);
  }

  // Deal with namespaces.
  if (in_array($type, array('function', 'function_or_constant', 'class'))) {
    $nameinfo = api_get_namespace_info($file_did);
    $name = api_full_classname($name, $nameinfo['namespace'], $nameinfo['use_alias']);
    $match_name = $query->addField('ad', 'namespaced_name', 'match_name');
    $match_name_field = 'ad.namespaced_name';
    $search_name = $query->addField('ad', 'object_name', 'search_name');
    $search_name_field = 'ad.object_name';
  }
  else {
    $match_name = $query->addField('ad', 'object_name', 'match_name');
    $match_name_field = 'ad.object_name';
    $search_name_field = NULL;
  }

  // Figure out what potential names we should match on.
  $potential_names = array($name);
  $prefer_shorter = FALSE;
  $prefer_earlier = FALSE;
  $search_term = NULL;

  if ($type == 'hook') {
    $potential_names = array(
      'hook_' . $name,
      'hook_entity_' . $name,
      'hook_field_' . $name,
      'field_default_' . $name,
      'hook_user_' . $name,
      'hook_node_' . $name,
    );
    $prefer_earlier = TRUE;
    $query->condition('ad.object_type', 'function');
    $search_term = '_' . $name;
  }
  elseif ($type == 'alter hook') {
    $potential_names = array('hook_' . $name . '_alter');
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'theme') {
    $potential_names = array();
    // Potential matches are the whole theme call, or with stripped off pieces
    // separated by __. And we look for template files preferably over
    // functions.
    $prefer_shorter = TRUE;
    $hook_elements = explode('__', $name);
    while (count($hook_elements) > 0) {
      $hook = implode('__', $hook_elements);
      $potential_names[] = str_replace('_', '-', $hook) . '.tpl.php';
      $potential_names[] = 'theme_' . $hook;
      array_pop($hook_elements);
    }
    // Because this needs to match theme files, change the query to match on
    // object title (which is the file base name).
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'))
      ->condition('ad.object_type', array('file', 'function'));
    $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
    $query->fields('b', array('branch_name', 'preferred', 'project'));
    if (is_null($branch)) {
      $query->condition('b.core_compatibility', $core_compatibility);
    }
    else {
      $query->condition('ad.branch_id', $branch->branch_id);
    }

    $match_name = $query->addField('ad', 'title', 'match_name');
    $match_name_field = 'ad.title';
  }
  elseif ($type == 'function') {
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'global') {
    $query->condition('ad.object_type', 'global');
  }
  elseif ($type == 'function_or_constant') {
    $query->condition('ad.object_type', array('function', 'constant', 'class', 'interface'));
  }
  elseif ($type == 'file') {
    // Because this needs to match files, change the query to match on
    // basename field in {api_files}.
    // @todo - would this work just matching on api_documentation.title?
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'))
      ->condition('ad.object_type', 'file');
    $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
    $query->fields('b', array('branch_name', 'preferred', 'project'));
    if (is_null($branch)) {
      $query->condition('b.core_compatibility', $core_compatibility);
    }
    else {
      $query->condition('ad.branch_id', $branch->branch_id);
    }
    $af = $query->innerJoin('api_file', 'af', 'ad.did = af.did');
    $match_name = $query->addField('af', 'basename', 'match_name');
    $match_name_field = 'af.basename';
  }
  elseif ($type == 'constant') {
    $query->condition('ad.object_type', 'constant');
  }
  elseif ($type == 'class') {
    $query->condition('ad.object_type', array('class', 'interface'));
  }
  elseif ($type == 'group') {
    $query->condition('ad.object_type', 'group');
  }

  // Execute the query and make an array of matches, making sure to only
  // keep the highest-priority matches.
  $query->condition($match_name_field, $potential_names);
  $results = $query->execute();
  $best = array();
  $name_matched = '';
  $preferred_matched = 0;
  foreach ($results as $object) {
    // MySQL is not case-sensitive, so check the match for exact string.
    $matched = $object->match_name;
    if (!in_array($matched, $potential_names)) {
      continue;
    }

    // See if this matched name takes precedence over the previous one.
    $priority = _api_match_priority($matched, $name_matched, $prefer_shorter, $potential_names, $prefer_earlier);
    if ($priority == 0 && ($preferred_matched == $object->preferred)) {
      // Same priority: add to array.
      $best[] = $object;
    }
    elseif ($priority > 0 || ($object->preferred == 1 && $preferred_matched == 0)) {
      // Higher priority: start new array.
      $best = array($object);
      $name_matched = $matched;
      $preferred_matched = 1;
    }
  }

  // See whether to return a direct link, a search, or FALSE.
  if (!count($best) || ($type == 'group' && count($best) != 1)) {
    return FALSE;
  }

  if (count($best) == 1) {
    $url = api_url($best[0]);
    $options = array(
      'attributes' => array(
        'title' => api_entity_decode($best[0]->summary),
        'class' => array('local'),
      ),
    );
    if ($type == 'group' && $text == $name) {
      // Override with the group name if no link text was provided.
      $text = $best[0]->title;
    }
    elseif ($type == 'group') {
      // If this is a topic link and someone provided text, then it was
      // check_plained at parse time. Don't double-encode it!
      $options['html'] = TRUE;
    }

    return l($text, $url, $options);
  }

  // @todo If we found multiple matches in the case of a multi-branch
  // search, we should probably go to a multi-branch search page, but this
  // does not exist yet. So just go to the first found branch.
  if (isset($search_name_field)) {
    $search_name = $best[0]->search_name;
  }
  else {
    $search_name = $best[0]->match_name;
  }

  $url = 'api/' . $best[0]->project . '/' . $best[0]->branch_name . '/search/' . $search_name;
  $options = array(
    'attributes' => array(
      'title' => t('Multiple implementations exist.'),
      'class' => array('local'),
    ),
  );
  return l($text, $url, $options);
}

/**
 * Checks if the name found has higher or lower priority than previous match.
 *
 * Helper function for api_link_name(), to distinguish between theme functions
 * and theme templates.
 *
 * @param $current
 *   Current matched string.
 * @param $previous
 *   Previous matched string.
 * @param $prefer_shorter
 *   TRUE to prefer shorter names.
 * @param $potential_names
 *   Array of the potential names we were matching on.
 * @param $prefer_earlier
 *   TRUE to prefer earlier matches in list of potential names.
 *
 * @return
 *   1 if previous is empty or current has higher priority. 0 if they have
 *   the same priority. -1 if current has lower priority.
 */
function _api_match_priority($current, $previous, $prefer_shorter = TRUE, $potential_names, $prefer_earlier) {
  if (strlen($previous) == 0) {
    return 1;
  }
  if ($current == $previous) {
    return 0;
  }

  // Theme templates have higher priority than theme functions.
  $current_is_theme_function = (strpos($current, 'theme_') === 0);
  $current_is_theme_template = (strpos($current, '.tpl.php') === strlen($current) - 8);
  $previous_is_theme_function = (strpos($previous, 'theme_') === 0);
  $previous_is_theme_template = (strpos($previous, '.tpl.php') === strlen($previous) - 8);
  if ($current_is_theme_function && $previous_is_theme_template) {
    return -1;
  }
  if ($current_is_theme_template && $previous_is_theme_function) {
    return 1;
  }

  // Prefer the shorter item.
  if ($prefer_shorter && (strlen($current) < strlen($previous))) {
    return 1;
  }
  if ($prefer_shorter && (strlen($previous) < strlen($current))) {
    return -1;
  }

  // Prefer the earlier item.
  if ($prefer_earlier) {
    $current_index = array_search($current, $potential_names);
    $previous_index = array_search($previous, $potential_names);
    if ($current_index === FALSE) {
      return -1;
    }
    if ($previous_index === FALSE) {
      return 1;
    }
    if ($current_index < $previous_index) {
      return 1;
    }
    if ($current_index > $previous_index) {
      return -1;
    }
  }

  // All things being equal...
  return 0;
}

/**
 * Attempts to locate a core branch corresponding to the given branch.
 *
 * @param $branch
 *   Branch object to find a core branch for.
 *
 * @return
 *   Branch object for the core branch, if there is one. If not, FALSE.
 */
function api_find_core_branch($branch) {
  $query = db_select('api_branch', 'b');
  $query->innerJoin('api_project', 'p', 'b.project = p.project_name');
  $query->condition('p.project_type', 'core');
  $query->condition('b.core_compatibility', $branch->core_compatibility);
  $query->fields('b');
  $query->fields('p', array('project_title', 'project_type'));
  $query->orderBy('b.weight', 'ASC');
  $result = $query->execute();
  // There shouldn't be more than one result, so assume that's the case and
  // return the first result found.
  foreach ($result as $branch) {
    api_unpack_branch_data($branch);
    return $branch;
  }

  return FALSE;
}

/**
 * Links text to an appropriate class member variable, constant, or function.
 *
 * @param $text
 *   Text matched by the regular expression.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Unused.
 * @param $append
 *   Unused.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class this is part of (if any).
 */
function api_link_member_name($text, $branch, $prepend = '', $append = '', $file_did = NULL, $class_did = NULL) {

  // The pattern matched to get here contains the entire span with all of its
  // classes. Parse it out.
  $matches = array();
  preg_match('!<span class="php-function-or-constant ([^"]+) member-of-([^"]+)">(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!', $text, $matches);
  $name = $matches[3];
  $member_type = $matches[2];
  $object_type = $matches[1];

  $prepend = '<span class="php-function-or-constant">';
  $append = '</span>';

  // Try matching in this branch.
  $link = _api_make_match_link_class_member($name, $member_type, $object_type, $class_did, $file_did, $branch);
  if ($link) {
    return $prepend . $link . $append;
  }

  // If this is not a core branch, try matching in the core branch, and then
  // in other branches with the same core compatibility.
  $core_branch = api_find_core_branch($branch);
  if ($core_branch && $core_branch->branch_id != $branch->branch_id) {
    $link = _api_make_match_link_class_member($name, $member_type, $object_type, $class_did, $file_did, $core_branch);
    if ($link) {
      return $prepend . $link . $append;
    }

    $link = _api_make_match_link_class_member($name, $member_type, $object_type, $class_did, $file_did, NULL, $branch->core_compatibility);
    if ($link) {
      return $prepend . $link . $append;
    }
  }

  // If we got here, we didn't have a match.
  return $prepend . $name . $append;
}

/**
 * Finds matches for a class member object name in a branch and makes a link.
 *
 * @param $name
 *   Name to match (text found in the code).
 * @param $member_type
 *   What type of reference to find: 'parent', 'self', 'variable', or
 *   'class-NAME'. This is set up in the parser.
 * @param $object_type
 *   'function' if this is a member function.
 * @param $class_did
 *   Documentation ID of the class this is part of (if any).
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $branch
 *   Object representing the branch to search. If NULL, use core compatibility
 *   instead.
 * @param $core_compatibility
 *   If $branch is NULL, search all branches with this core compatibility.
 *
 * @return
 *   Link to either a single matching object or a search if multiple matches
 *   exist; if there are no matches, FALSE.
 */
function _api_make_match_link_class_member($name, $member_type, $object_type, $class_did = NULL, $file_did = NULL, $branch = NULL, $core_compatibility = '') {

  // If $member_type is parent, see if the parent class exists in this branch.
  if ($member_type == 'parent') {
    $query = db_select('api_reference_storage', 'ars');
    $ad = $query->innerJoin('api_documentation', 'ad', 'ad.namespaced_name = ars.object_name');
    $query
      ->fields($ad, array('did'))
      ->condition('ars.from_did', $class_did)
      ->condition('ars.object_type', 'class')
      ->condition('ad.object_type', 'class');

    if (is_null($branch)) {
      $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
      $query->condition('b.core_compatibility', $core_compatibility);
    }
    else {
      $query->condition('ad.branch_id', $branch->branch_id);
    }

    $class_did = $query->execute()->fetchCol();
    $member_type = 'self';
    if (count($class_did) == 1) {
      $class_did = array_pop($class_did);
    }
    elseif (count($class_did) == 0) {
      return FALSE;
    }
  }

  // If we're looking for a specific class, see if it exists in this branch.
  if (strpos($member_type, 'class-') === 0) {
    $class_name = substr($member_type, 6);
    // Put on the correct namespace.
    $ns_info = api_get_namespace_info($file_did);
    $full_class_name = api_full_classname($class_name, $ns_info['namespace'], $ns_info['use_alias']);
    $query = db_select('api_documentation', 'ad');
    $query->fields('ad', array('did'))
      ->condition('object_type', 'class')
      ->condition('namespaced_name', $full_class_name);
    if (is_null($branch)) {
      $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
      $query->condition('b.core_compatibility', $core_compatibility);
    }
    else {
      $query->condition('ad.branch_id', $branch->branch_id);
    }
    $class_did = $query->execute()->fetchCol();
    $member_type = 'self';
    if (count($class_did) == 1) {
      $class_did = array_pop($class_did);
    }
    elseif (count($class_did) == 0) {
      // Class is not in this branch.
      return FALSE;
    }
  }

  $result = NULL;
  if ($member_type == 'self') {
    // Looking for a member of a particular class, or one of several classes,
    // whose documentation ID we have already located. Use the {api_members}
    // table to find the right method, since it includes members inherited from
    // parent classes.
    $query = db_select('api_members', 'am');
    $ad = $query->innerJoin('api_documentation', 'ad', 'ad.did = am.did');
    $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
    $query
      ->fields('ad', array('branch_id', 'title', 'object_name', 'summary', 'object_type', 'file_name', 'did', 'member_name'))
      ->fields('b', array('branch_name', 'project'))
      ->condition('am.class_did', $class_did)
      ->condition('ad.member_name', $name);

    if ($object_type == 'function') {
      $query->condition('ad.object_type', 'function');
    }
    else {
      $query->condition('ad.object_type', 'function', '<>');
    }

    $result = $query->execute();
  }
  elseif ($member_type == 'variable') {
    // This was some kind of a variable like $foo->member(). So match any member
    // of any class in this branch.
    $query = db_select('api_documentation', 'ad');
    $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
    $query
      ->fields('ad', array('branch_id', 'title', 'object_name', 'summary', 'object_type', 'file_name', 'did', 'member_name'))
      ->fields('b', array('branch_name', 'project'))
      ->condition('ad.member_name', $name);

    if (is_null($branch)) {
      $query->condition('b.core_compatibility', $core_compatibility);
    }
    else {
      $query->condition('ad.branch_id', $branch->branch_id);
    }

    if ($object_type == 'function') {
      $query->condition('ad.object_type', 'function');
    }
    else {
      $query->condition('ad.object_type', 'function', '<>');
    }

    $result = $query->execute();
  }

  // See if we have one result, more than one result, or no results.
  $matches = array();
  if (isset($result)) {
    foreach ($result as $object) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->member_name != $name) {
        continue;
      }
      $matches[] = $object;
    }
  }

  // No matches.
  if (!count($matches)) {
    return FALSE;
  }

  // If we found one match, return its URL as a link.
  if (count($matches) == 1) {
    $object = $matches[0];
    $url = api_url($object);
    $options = array(
      'attributes' => array(
        'title' => api_entity_decode($object->summary),
        'class' => array('local'),
      ),
    );
    return l($name, $url, $options);
  }

  // If we found multiple matches, make a search URL.
  // @todo If we found multiple matches in the case of a multi-branch
  // search, we should probably go to a multi-branch search page, but this
  // does not exist yet. So just go to the first found branch.
  $url = 'api/' . $matches[0]->project . '/' . $matches[0]->branch_name . '/search/' . $name;
  $options = array(
    'attributes' => array(
      'title' => t('Multiple implementations exist.'),
      'class' => array('local'),
    ),
  );
  return l($name, $url, $options);
}

/**
 * Decodes HTML entities.
 *
 * @param $text
 *   Text to decode.
 *
 * @return
 *   Text with all HTML entities decoded.
 */
function api_entity_decode($text) {
  $text = html_entity_decode($text);
  // html_entity_decode does not decode numeric entities, and there are
  // many cases of &#39; (quote) in here.
  $text = str_replace('&#039;', "'", $text);
  $text = str_replace('&#39;', "'", $text);
  return $text;
}

/**
 * Turns text into a link, using the first word as the object name.
 *
 * @param $name
 *   Text to link.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class the link is in (if any).
 *
 * @return
 *   The text as a link.
 */
function api_link_link($name, $branch, $prepend = '', $append = '', $file_did = NULL, $class_did = NULL) {
  $words = preg_split('/\s+/', trim($name));
  $name = array_shift($words);
  return api_link_name($name, $branch, $prepend, $append, $file_did, $class_did, implode(' ', $words), TRUE);
}

/**
 * Flags a file, branch, or all branches, to be reparsed on the next cron run.
 *
 * @param $branch_or_file
 *   (optional) Identifier or ID number of the branch to reparse, or name of a
 *   single file to reparse. If omitted all branches will be reparsed. File
 *   names must include the path relative to the common path to the directories
 *   indexed by this branch.
 * @param $is_branch_name
 *   If passing in a branch name, set to TRUE so that if it happens to be an
 *   integer, it won't be considered to be a branch ID number by mistake.
 *   Otherwise, just leave this as the default FALSE.
 *
 * @return
 *   Number of files marked for reparsing.
 */
function api_mark_for_reparse($branch_or_file = NULL, $is_branch_name = FALSE) {
  $time_in_past = 52;

  // See if it's a request to reparse everything.
  if (empty($branch_or_file)) {
    return db_update('api_file')
      ->fields(array(
          'modified' => $time_in_past,
        ))
      ->execute();
  }

  // See if it's a request for a particular branch.
  if (!$is_branch_name && is_numeric($branch_or_file) && ($branch_or_file == intval($branch_or_file))) {
    $branch_id = $branch_or_file;
  }
  else {
    $branch_id = db_select('api_branch', 'b')
      ->fields('b', array('branch_id'))
      ->condition('branch_name', $branch_or_file)
      ->execute()
      ->fetchField();
  }

  if (!empty($branch_id)) {
    // Reparse a branch.
    // This is a query using a WHERE EXISTS, and there is no apparent way
    // to write it using the database API, so use ANSI syntax.
    $out = db_query("UPDATE {api_file} SET modified = :mod_time WHERE EXISTS ( SELECT * FROM {api_documentation} d WHERE d.branch_id = :branch_id AND d.object_type = 'file' AND d.did = {api_file}.did )", array(':mod_time' => $time_in_past, ':branch_id' => $branch_id));
    return $out->rowCount();
  }

  // If we get here, it's a request to reparse just one file. So find the file
  // ID, and then request its reparse.
  $did = db_select('api_documentation', 'd')
    ->fields('d', array('did'))
    ->condition('file_name', $branch_or_file)
    ->condition('object_type', 'file')
    ->execute()
    ->fetchField();

  if ($did) {
    $out = db_update('api_file')
      ->fields(array(
          'modified' => $time_in_past,
        ))
      ->condition('did', $did)
      ->execute();

    return $out;
  }

  return 0;
}

/**
 * Parses a queued file.
 *
 * @data
 *   Array of information about the file to be parsed.
 */
function api_queue_parse_file($data) {
  // Verify that the branch this job was saved with still exists.
  $branch = $data['branch'];
  $new_branch = api_get_branch_by_id($branch->branch_id);
  if (is_null($new_branch)) {
    watchdog('api', 'Invalid or deleted branch requested in API parse %project branch %branch %file', array('%branch' => $branch->branch_name, '%project' => $branch->project, '%file' => $data['file']));
    return;
  }
  $branch = $new_branch;

  // Verify that it's still a valid parse job (if the branch has been updated,
  // the parse job is not valid any more).
  $when_queued = (isset($data['timestamp']) ? $data['timestamp'] : 0);
  $valid_time = (isset($branch->queue_valid) ? $branch->queue_valid : 0);
  if ($when_queued < $valid_time) {
    watchdog('api', 'Skipped API parse %project branch %branch %file', array('%branch' => $branch->branch_name, '%project' => $branch->project, '%file' => $data['file']));
    return;
  }

  if ($when_queued >= $valid_time) {
    watchdog('api', 'API parse %project branch %branch %file', array('%branch' => $branch->branch_name, '%project' => $branch->project, '%file' => $data['file']));

    module_load_include('inc', 'api', 'parser');
    api_parse_file($data['parser'], $data['path'], $branch, $data['file']);
  }
}

/**
 * Checks a queued branch for updates.
 *
 * @data
 *   Array of information about the branch to be checked for updates.
 */
function api_queue_update_branch($data) {
  $type = $data['type'];
  $id = $data['branch_id'];
  if ($type == 'files') {
    $branch = api_get_branch_by_id($id);
    if (!is_null($branch)) {
      module_load_include('inc', 'api', 'parser');
      api_update_branch_files($branch);
      return;
    }
  }

  if ($type == 'php') {
    $branches = api_get_php_branches();
    if (isset($branches[$id])) {
      module_load_include('inc', 'api', 'parser');
      api_update_branch_php($branches[$id]);
      return;
    }
  }

  watchdog('api', 'Invalid or deleted branch requested in API update %type branch %branch', array('%type' => $type, '%branch' => $id), WATCHDOG_ERROR);
}

/**
 * Deletes obsolete nodes.
 *
 * @param $data
 *   Array with element 'nids' giving the IDs of the nodes to delete.
 */
function api_queue_node_delete($data) {
  watchdog('api', 'Removing a batch of %count obsolete nodes.', array('%count' => count($data['nids'])));
  node_delete_multiple($data['nids']);
}

/**
 * Resets the parse queue.
 *
 * Empties all parse jobs from the queue, and sets all files to "unqueued"
 * status.
 */
function api_reset_parse_queue() {
  $queue = DrupalQueue::get('api_parse');
  $queue->deleteQueue();

  db_update('api_file')
    ->fields(array(
        'queued' => 0,
      ))
    ->execute();
}

/**
 * Verifies that the required libraries are loaded.
 *
 * @param $watchdog
 *   TRUE to log an error if the library is not loaded (first time only).
 *
 * @return
 *   TRUE if OK, FALSE if parsing will not work.
 */
function api_libraries_loaded($watchdog = TRUE) {
  static $loaded = NULL;
  if (!is_null($loaded)) {
    return $loaded;
  }

  if (!gplib_version_check(FALSE)) {
    if ($watchdog) {
      watchdog('api', 'Grammar Parser library is not installed or version is incompatible.', array(), WATCHDOG_ERROR);
    }
    $loaded = FALSE;
    return FALSE;
  }

  $library = libraries_load('grammar_parser');
  $loaded = !empty($library['loaded']);
  if ($watchdog && !$loaded) {
    watchdog('api', 'Grammar Parser library is not loaded. Unable to parse files.', array(), WATCHDOG_ERROR);
  }

  return $loaded;
}

/**
 * Deletes a branch and all of its related documentation records.
 *
 * @param $branch_id
 *   The numeric ID of the branch to delete.
 * @param $finalize
 *   TRUE to redo the menus etc., FALSE to postpone (because other deletes
 *   are coming).
 */
function api_delete_branch($branch_id, $finalize = TRUE) {
  // Find out which documentation IDs need to be deleted.
  $dids = db_select('api_documentation', 'ad')
    ->fields('ad', array('did'))
    ->condition('branch_id', $branch_id)
    ->execute()
    ->fetchCol();

  // Fully delete these items, and the branch record.
  api_delete_items($dids);
  db_delete('api_branch')
    ->condition('branch_id', $branch_id)
    ->execute();

  if ($finalize) {
    api_reset_branches();
  }
}

/**
 * Deletes a PHP reference branch and all of its related documentation records.
 *
 * @param $branch_id
 *   The numeric ID of the branch to delete.
 */
function api_delete_php_branch($branch_id) {
  db_delete('api_php_documentation')
    ->condition('branch_id', $branch_id)
    ->execute();
  db_delete('api_php_branch')
    ->condition('branch_id', $branch_id)
    ->execute();

  api_get_php_branches(TRUE);
}

/**
 * Deletes a project and all of its branches and documentation records.
 *
 * @param $project_name
 *   The name of the project to delete.
 */
function api_delete_project($project_name) {
  // Delete all of the branches.
  $branch_ids = db_select('api_branch', 'b')
    ->condition('project', $project_name)
    ->fields('b', array('branch_id'))
    ->execute()
    ->fetchCol();
  foreach ($branch_ids as $id) {
    api_delete_branch($id, FALSE);
  }

  // Delete the project itself.
  db_delete('api_project')
    ->condition('project_name', $project_name)
    ->execute();

  // Clean up.
  api_reset_branches();
}

/**
 * Completely deletes an array of documentation items.
 *
 * All records pertaining to the items, including nodes and comments, are
 * removed. If there are a lot, the batch API may be invoked, or a job may
 * be queued.
 *
 * @param $dids
 *   Array of the IDs of the items to delete.
 * @param $interactive
 *   TRUE if the batch_set() can be used if there are too many items to delete;
 *   FALSE if queue jobs need to be set up instead.
 *
 * @return
 *   TRUE if the items were deleted directly; FALSE if a batch or queue job
 *   was set up to delete some of them. In this case, in interactive mode, the
 *   calling function needs to ensure that the batch is processed. This is
 *   automatic if it's part of a form submission handler, but not otherwise.
 */
function api_delete_items($dids, $interactive = TRUE) {
  // Count the cumulative effect of calls in this page request.
  static $total_count = 0;

  // If there's nothing to do, return early.
  $count = count($dids);
  if ($count < 1) {
    return TRUE;
  }

  // Delete the items from api tables in batches of 100, because placeholder
  // queries can be a problem. This is fast though, so do not worry about
  // batching.
  $done = 0;
  while ($done < $count) {
    $this_batch = array_slice($dids, $done, 100);
    $done += 100;

    db_delete('api_documentation')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('class_did', $this_batch)
      )
      ->execute();
    db_delete('api_file')
      ->condition('did', $this_batch)
      ->execute();
    db_delete('api_namespace')
      ->condition('did', $this_batch)
      ->execute();
    db_delete('api_function')
      ->condition('did', $this_batch)
      ->execute();
    db_delete('api_members')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('class_did', $this_batch)
      )
      ->execute();
    db_delete('api_overrides')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('overrides_did', $this_batch)
        ->condition('documented_did', $this_batch)
      )
      ->execute();
    db_delete('api_reference_storage')
      ->condition('from_did', $this_batch)
      ->execute();
    db_delete('api_extends')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('parent_did', $this_batch)
      )
      ->execute();
  }

  // The slow part is deleting the nodes. If there are more than 100 to delete
  // during this page request, do them using batch/queue jobs.
  // Also, if this particular call has only a few nodes, go ahead and delete,
  // to avoid having a ton of small jobs in the queue from a branch update.
  $total_count += $count;
  if ($total_count < 100 || $count < 5) {
    node_delete_multiple($dids);
    return TRUE;
  }

  // If we get here, we need to use batch/queue to delete the nodes.
  if ($interactive) {
    batch_set(array('operations' => array(array('_api_delete_nodes_batch', array($dids)))));
  }
  else {
    $queue = DrupalQueue::get('api_node_delete');
    $done = 0;
    while ($done < $count) {
      $this_batch = array_slice($dids, $done, 100);
      $done += 100;
      $queue->createItem(array('nids' => $this_batch));
    }
  }

  return FALSE;
}

/**
 * Deletes API nodes using the Batch API.
 *
 * @param $nids
 *   IDs of the nodes to delete.
 * @param $context
 *   Batch context.
 */
function _api_delete_nodes_batch($nids, &$context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = count($nids);
    $context['sandbox']['nids'] = $nids;
  }

  $this_batch = array_slice($context['sandbox']['nids'], $context['sandbox']['progress'], 100);
  $context['sandbox']['progress'] += count($this_batch);
  node_delete_multiple($this_batch);
  $context['finished'] = min(1, $context['sandbox']['progress'] / $context['sandbox']['max']);
  if (!count($this_batch)) {
    // Just make sure we don't run an endless loop here.
    $context['finished'] = 1;
  }
}

/**
 * Performs AJAX autocomplete for projects.
 */
function api_project_autocomplete($string = '') {
  $matches = array();
  if ($string) {
    $result = db_select('api_project', 'p')
      ->fields('p', array('project_name'))
      ->condition('project_name', db_like($string) . '%', 'LIKE')
      ->orderBy('project_name')
      ->range(0, 10)
      ->execute()
      ->fetchCol();
    foreach ($result as $name) {
      $matches[$name] = check_plain($name);
    }
  }

  drupal_json_output($matches);
}

/**
 * Performs AJAX autocomplete for search.
 */
function api_search_autocomplete($branch_id, $string = '') {
  $matches = array();

  if ($string) {
    $result = db_select('api_documentation', 'ad')
      ->fields('ad', array('title'))
      ->condition('branch_id', $branch_id)
      ->condition('title', '%' . db_like($string) . '%', 'LIKE')
      ->orderBy('LENGTH(title)')
      ->range(0, 20)
      ->execute()
      ->fetchCol();
    foreach ($result as $name) {
      $matches[$name] = check_plain($name);
    }
  }

  drupal_json_output($matches);
}

/**
 * Implements hook_views_api().
 */
function api_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'api') . '/views',
    'template path' => drupal_get_path('module', 'api') . '/views/templates',
  );
}

/**
 * Unpacks and adds defaults to branch data.
 */
function api_unpack_branch_data($branch) {
  drupal_unpack($branch);
  if (!isset($branch->directories)) {
    $branch->directories = '';
  }
  if (!isset($branch->excluded_directories)) {
    $branch->excluded_directories = '';
  }
  if (!isset($branch->exclude_files_regexp)) {
    $branch->exclude_files_regexp = '';
  }
}

/**
 * Displays the output of a view, assumed to be a block display.
 *
 * @param $view_name
 *   Machine name of the view.
 * @param $display_name
 *   Machine name of the display within the view.
 * @param $args
 *   (optional) Array of arguments for the view display.
 *
 * @return
 *   String containing the view output. If the view was empty, an empty string.
 */
function api_display_view($view_name, $display_name, $args = array()) {
  $output = '';

  // Load the view.
  $view = views_get_view($view_name);

  if ($view) {
    // Override the URL so that exposed filters will work on blocks even without
    // AJAX.
    $view->override_url = current_path();
    $output = $view->preview($display_name, $args);
  }

  // Check for no content.
  if (!strlen(trim(strip_tags($output)))) {
    $output = '';
  }

  return $output;
}
